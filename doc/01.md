## BOLT #01-ベースプロトコル

### 概要

このプロトコルは基本的な認証と個別のメッセージを構築する転送の仕組みに従っていることを前提とします。  
[BOLT #8](08.md)ではLightningで使用されるトランスポート層について詳細が述べられています。  

デフォルトのTCPポートは'9735'であり、これは16進数の'0x2607'、ユニコードの[LIGHTNING](http://www.unicode.org/charts/PDF/U2600.pdf)に由来します。  

また、全てのデータフィールドは特に言及のない限り符号無しのビッグエンディアンです。  

## 目次

- [接続の処理と多重化](#接続の処理と多重化)  
- [Lightningメッセージの形式](#Lightningメッセージの形式)
- [Type-Length-Valueフォーマット](#Type-Length-Valueフォーマット)
- [基本のtype](#基本の`type`)
- [セットアップメッセージ](#セットアップメッセージ)
    - [初期化メッセージ(`init`)](#初期化メッセージ(`init`))
    - [エラーメッセージ(`error`)](#エラーメッセージ(`error`))
- [コントロールメッセージ](#コントロールメッセージ)
    - [応答メッセージ(`ping`, `pong`)](#応答メッセージ(`ping`,`pong`))
    
- [参考](#参考)

## 接続の処理と多重化

ピアごとの接続について必ず単一接続を使用しなければなりません。  
channel IDを含むチャネルメッセージはこの単一接続の上に多重化されます。  

## Lightningメッセージの形式

復号化のあと、全てのLightningメッセージは以下のようになっています。

1. `type`: メッセージタイプを示す、2バイトのビッグエンディアンフィールド  
2. `payload`: `type`に該当する形式の可変長のメッセージ  

`type`はどのように`payload`を変換するかを指定します。  
以下に標準仕様といての`type`の定義を示しますが、他の仕様を採用しても良いため受信者が処理できるかを確認することなく、別仕様の`type`として送信することも可能です。  

**送信ノード**
- 前もっての通信なしに、リストにないタイプのメッセージを送ってはいけません。  

**受信ノード**
- 奇数の知らないtypeの場合、受信メッセージを無視しなければなりません。  
- 偶数の知らないtypeの場合、チャネルオープンを失敗しなければなりません。  

メッセージは以下のように4つのグループに分類されます。
1. セットアップ、コントロール(`0`〜`31`)  
    接続のセットアップやコントロール、機能のサポート、[エラーレポート]()に使用。
2. チャネル(`32`〜`127`)  
    マイクロペイメントのチャネルのセットアップやクローズに使用。([BOLT #2](02.md)を参照)
3. コミットメント(`128`〜`255`)  
    直近のコミットメントトランザクションの更新(追加、取り消し(revork)、HTLCの設定)に使用。
4. ルーティング(`256`〜`511`)  
    現在有効なルートの探索情報といったノードやチャネル情報の送信に使用。  

トランスポート層に適合するよう、メッセージのサイズは符号無しの2バイトである必要があります。  
そのため、最大のサイズは65535バイトになります。  

**ノードについて**
- typeが想定するメッセージ長を超過した分のメッセージは無視しなければならない。
- 長さが足りない既知のメッセージを受信した際は、チャネルオープンを失敗しなければなりません。
- 仕様内のオプションについての交渉はオプション内の全ての注釈を含んでいる必要があります。

## Type-Length-Valueフォーマット 

プロトコル全体で、TLV(Type-Length-Value)形式を使用することで既存のメッセージタイプに新しいフィールドを後方互換で追加できます。

`tlv_record`は単一フィールドで表され、以下のように暗号化されます。
- [varint: type]
- [varint: length]
- [length: value]

'varint'はBigSizeを使用している符号無しのintの可変長です。

`tlv_stream`は暗号化された`tlv_record`を結合したものです。  
通常、既存のメッセージを拡張する場合、現在定義されている全フィールドに`tlv_stream`が置かれます。  

`type`はBigSizeを使用している符号無しの可変長です。  
これはメッセージの仕様を示す機能をもっており、`tlv_record`の64ビットの識別子が`value`についてどのような構成なのか特定します。  
2の16乗未満の`type`はこの仕様で予約されており、2の16乗に等しい、もしくは大きい場合は カスタムして使用することができます。  

`length`はBigSizeを使用している可変長で、`value`のバイト数を表しています。  

`value`は`type`に依存しており、`type`によって定められている仕様で暗号化・復号化されます。  

### 必要要件

**送信ノード**

- `tlv_stream`の`tlv_records`は`type`の昇順でなければいけません。  
- `type`と`length`のエンコードは最小限でなければいけません。  
- `type`の識別子をカスタムして使用する場合、
    - 他の識別子との重複を防ぐためランダムな値を選択します。
    - 通常のノードが追加データを無視する必要がある場合は奇数を選択します。
    - 通常のノードはカスタムレコードを含むtlvのメッセージ全体を拒否する必要がある場合は偶数を選択します。
- `tlv_record`の中の可変長の暗号化は余分な要素のないようにしなければいけません。  

**受信ノード**

以下の場合、`tlv_stream`の解析を中止しなければいけません。  

1. `type`の解析前に0バイトが残っている
2. `type`や`length`が最小限で暗号化されてない
3. 復号化された`type`が昇順でない
4. `length`がメッセージのバイト数を超えている
- 認識できる`type`の場合、その`type`にて次の`length`を復号化しなければいけませんが、  
    5. `length`がその復号化に使用した`type`の要件に一致しなかった  
    6. 復号化された`type`内の可変長のフィールドが最小でない
- 認識できない`type`の場合、  
    7. `type`が偶数  
    ※`type`が奇数のときは、次の`length`のバイトを破棄しなければいけません。  

## 基本の`type`

メッセージ仕様では様々な基本の`type`が参照されます。  

- `byte`: 8ビット
- `u16`: 2バイトの符号無し整数
- `u32`: 4バイトの符号無し整数
- `u64`: 8バイトの符号無し整数

単一の値を持つTLVレコード内(先頭の0は省略可能)

- `tu16`: 0〜2バイトの符号無し整数
- `tu32`: 0〜4バイトの符号無し整数
- `tu64`: 0〜8バイトの符号無し整数

よく使用される`type`は以下の通り定義されています。  

- `chainhash`: 32バイトのチェーン識別子([BOLT #0](00.md))
- `channel_id`: 32バイトのチャネルID([BOLT #2](02.md))
- `sha256`: 32バイトのSHA2-256ハッシュ
- `signature`: 64バイトのビットコイン楕円曲線署名
- `point`: 33バイトの楕円曲線点([SEC 1 standard](http://www.secg.org/sec1-v2.pdf#subsubsection.2.3.3)に従い圧縮されているエンコード)
- `short_channel_id`: 8バイトのチャネル判別値([BOLT #7](07.md))

## セットアップメッセージ

### 初期化メッセージ(`init`)

一旦認証が完了すると、再接続時でも最初のメッセージに、このノードで必要もしくはサポートされる機能が示されます。

[BOLT #9](09.md)に機能のリストが載っており、一般的にそれぞれの機能は2ビットで表されます。  

`features`フィールドは0でバイトに埋め込まれなければいけません。  

1. type: 16(`init`)  
2. data:  
    - [`u16`:`gflen`]
    - [`gflen*byte`:`glonbalfeatures`]
    - [`u16`:`flen`]
    - [`flen*byte`:`features`]

#### 必要要件

**送信ノード**

- どのような接続においても最初のLightningメッセージとして`init`を送信しなければいけません。  
- [BOLT #9](09.md)に定められている機能ビットを設定しなければいけません。  
- 定義されていない機能ビットを0に設定しなければいけません。  
- `globalfeatures`では13より上の機能を極力使用しない。
- `features`フィールドを表すためには最小の長さになるようにします。  

**受信ノード**

- 他のメッセージを送るより前に`init`の受信を待たなければいけません。  
- 2つの機能ビットマップを1つの論理`features`マップに論理ORで結合しなければいけません。  
- [BOLT #9](09.md)に定められている機能ビットには応答しなければいけません。  
- 認識できない0でない奇数ビットを受信した場合、そのビットを無視しなければいけません。  
- 認識できない0でない偶数ビットを受信した場合、接続を失敗しなければいけません。  

### エラーメッセージ(`error`)

何か間違いがあった際に、それを相手ノードに知らせることで判断の簡素化に役立ちます。

1. type: 17(`error`)
2. data:  
    - [`cahnnel_id`:`channel_id`]
    - [`u16`:`len`]
    - [`len*byte`:`data`]

2バイトの`len`フィールドは、後に続くフィールドのバイト数を表します。  

#### 必要要件

チャネルは`channel_id`が0(つまり全てのバイトが0)でない限り、`channel_id`によって参照され、この際全てのチャネルを参照します。  

**fundingするノード**

- 全てのエラーメッセージは`funding_created`の前もしくは中に含めて送信されます。  
このメッセージには`channel_id`の代わりに`temporary_channel_id`が使用されなければいけません。  

**fundingされるノード**

- 全てのエラーメッセージは`funding_signed`の前もしくは中に含めて送信されます。  
このメッセージには`channel_id`の代わりに`temporary_channel_id`が使用されなければいけません。  

**送信ノード**

- `error`送信時にはエラーメッセージにあるチャネルを失敗させなければいけません。  
- プロトコル違反や、チャネルを使用不能にしたり、さらに通信を使用できなくする内部エラーに対して`error`を送信する必要があります。  
- 不明なチャネルについてのメッセージタイプ(32〜255)への応答には不明な`channel_id`を`error`に含める必要があります。  
- 空の`data`フィールドを送信することができます。  
- 無効な署名が確認されたことで失敗した場合、`funding_created`、`funding_signed`、`closing_signed`、`commitment_signed`への応答のために、16進数で暗号化された生トランザクションを含める必要があります。  
- `channel_id`が0の場合、受信したノードから全てのチャネルを失敗させ、接続を終了しなければいけません。  
- `data`の長さと`len`は等しくなるよう設定しなければいけません。  

**受信ノード**

- エラーメッセージを受信して、そのメッセージに示されているチャネルが送信ノードと開いているチャネルだった場合、そのチャネルを失敗させなければいけません。  
- エラーメッセージに示されているチャネルが存在しないチャネルだった場合、そのメッセージを無視しなければいけません。  
- パケットが大きすぎる場合、切り捨てなければいけません。  
- `data`が表示可能なASCII文字のみで構成されていない場合、その通りに表示する必要はありません。  
(表示可能な文字セットには32〜126のバイト値が含まれています。)  


## コントロールメッセージ

### 応答メッセージ(`ping`,`pong`)

長期間のTCP接続を実現するため、両端のノードでアプリケーションレベルでTCP接続を持続させる必要があります。  
また、そのようなメッセージはトラフィックパターンの難読化も可能にします。  

1. type: 18(`ping`)
2. data:  
    - [`u16`:`num_pong_bytes`]
    - [`u16`:`byteslen`]
    - [`byteslen*byte`:`ignored`]

`ping`メッセージを受信した場合、必ず`pong`メッセージが返されるようにします。  
これによって、受信ノードがまだ動作しており、接続を続けることを送信ノードに明示します。  
`ping`メッセージを送信したノードは、そのメッセージ内で`pong`メッセージのデータペイロードに含めるバイト数を指定します。  

1. type: 19(`pong`)
2. data:  
    - [`u16`:`byteslen`]
    - [`byteslen*byte`:`ignored`]

#### 必要要件

**`ping`の送信ノード**

- `ignored`を0に設定します。  
- `ignored`に機密データを設定してはいけません。  
- `pong`メッセージを受信しなかった場合、ネットワーク接続を終了します。  
※この時、チャネルは失敗させてはいけません。  
- 30秒に1回以上の`ping`メッセージを送信しないようにします。  

**`pong`の送信ノード**

- `ignored`を0に設定します。  
- `ignored`に機密データを設定してはいけません。  

**`ping`の受信ノード**

- 30秒以内に数回`ping`を受信する場合はチャネルを失敗させます。  
- `num_pong_bytes`が65532より小さい場合、その値と`byteslen`が等しくなるよう`pong`メッセージを送らなければいけません。  
- `num_pong_bytes`が65532以上の場合、`ping`を無視しなければいけません。  

**`pong`の受信ノード**

- `byteslen`が送信した`ping`の`num_pong_bytes`と一致しなかった場合、チャネルを失敗させます。  
## 参考

<http://www.unicode.org/charts/PDF/U2600.pdf>  
