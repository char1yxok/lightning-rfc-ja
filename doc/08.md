## BOLT #08-メッセージの暗号化と認証

### 概要

Lightningにおけるノード間のメッセージの通信内容は情報を内秘にするために暗号化され、またなりすましや書き換え等の悪意のある妨害を防ぐために認証を必要とします。

### 目次

- [ハンドシェイク](#ハンドシェイク)  
    - [初期化](#初期化)
    - [Act1](#Act1)
    - [Act2](#Act2)
    - [Act3](#Act3)
- [参考](#参考)

### ハンドシェイク

Lightningのノードがsend coinやfundingをする(=暗号化されたLightning messageを送り合う)前にハンドシェイクという鍵交換を行い、成功したら上記のような暗号化メッセージの送受信が可能になります。

このハンドシェイクには[Noise Protocol Framework](http://www.noiseprotocol.org/noise.html)というフレームワークを使用します。

上記フレームワークにも様々な種類のハンドシェイクが存在しますが、Lightningでは**Noise-XK**というものを使用します。  
以下が簡略化した流れ図です。

initiator(左): 自ノード  
responder(右): 相手ノード  

(初期化)  
(Act1)  1  ->  2  
(Act2)  4  <-  3  
(Act3)  5  ->  6  

この通り、Noise-XKでは1から6まで順に処理され、計3回のやりとりが行われます。  
ハッシュダイジェスト(h)というある値に、またある値を付け足して暗号化して送信し、受信側はそれを復号化して、また値を付け足して暗号化して送信・・・といった形で進んでいきます。  
これからそれぞれの処理がどのようなことを行なっているのか見ていきます。

#### 初期化

まずinitiatorはresponderの静的公開鍵を知っている前提からAct1は始まります。  
この公開鍵を使ってinitiator、responder共に’h’を作成します。  
ちなみに’SHA-256’とはハッシュ関数の一つです。  
下の'h'であればprotocolNameの値をSHA-256を通したハッシュ値が'h'になります。

`h = SHA-256(protocolName)`

※protocolName = ’Noise_XK_secp256k1_ChaChaPoly_SHA256’をASCIIコード変換したもの

`ck = h`

`h = SHA-256(h || prologue)`

※prologue = ’lightning’をASCIIコード変換したもの

次にinitiator、responderは共にresponderの静的公開鍵をシリアライズ化して’h’に付け足します。

- initiator  
`h = SHA-256(h || rs.pub.serializeCompressed())`

- responder  
`h = SHA-256(h || ls.pub.serializeCompressed())`

#### Act1

ここからは上記図の数字ごとに処理を追います。

**1 (initiator action)**

1. まずinitiatorの秘密鍵'e'を作成します。  
`e = generateKey()`

2. 次にeの公開鍵をシリアライズ化して’h’に付け足します。  
`h = SHA-256(h || e.pub.serializeCompressed())`

3. 先ほど作成した秘密鍵'e'とresponderの公開鍵'rs'を元にして'es'を求めます。  
`es = ECDH(e.priv, rs)`

4. initiator、responder共通の'ck'(protocolNameをSHA-256した値)と一つ手前で作った'es'から一時鍵'temp_k1'を作成します。  
`ck, temp_k1 = HKDF(ck, es)`

5. これまでに作成した一時鍵'temp_k1'、'h'、そして数字の0とzero(="")を使って暗号化した'c'を作成します。  
`c = encryptWithAD(temp_k1, 0, h, zero)`

6. そして'h'に付け足してSHA-256します。  
`h = SHA-256(h || c)`

7. 最後に数値の0、はじめに作成した公開鍵のシリアライズ化したもの、'c'をひとまとめにした'm'をresponderへ送信します。  
`m = 0 || e.pub.serializeCompressed() || c`  
'm'は50バイトと定められており、先頭の1バイトがバージョン、自身が作成した公開鍵のシリアライズ化したものが33バイト、'c'が16バイトです。

**2 (responder action)**

1. まず、受信した'm'の先頭バイトを確認し、異なるバージョンの場合はエラーとして通信を中断します。  

2. 'm'に含まれるinitiatorの公開鍵をデシリアライズ化した're'を初期化フェーズで作成した'h'に付け足してSHA-256します。  
`h = SHA-256(h || re.serializeCompressed())`

3. はじめにinitiatorが持っていたresponderの公開鍵'rs'の元である秘密鍵とinitiatorの公開鍵を元にして'es'を作成します。  
`es = ECDH(s.priv, re)`

4. initiator、responder共通の'ck'(protocolNameをSHA-256した値)と一つ手前で作った'es'から一時鍵'temp_k1'を作成。  
`ck, temp_k1 = HKDF(ck, es)`

5. これまでに作成した一時鍵'temp_k1'、'h'、そして数字の0と'c'を使って復号化した'p'を作成します。  
`p = decryptWithAD(temp_k1, 0, h, c)`  
もしここで、pの値と'm'に含まれる'c'の値が異なる場合はそこで通信を中断します。  
'p'と'm'が一致しないということは、initiatorがresponderの公開鍵を知らないということになるためです。

6. 無事、responderが作成した'p'とinitiatorが作成した'm'が一致したら、'h'に'c'を付け足してSHA-256します。  
`h = SHA-256(h || c)`

以上がAct1になります。

#### Act2

Act2は基本的にAct1の逆方向に同様の確認作業を行います。

**3 (responder action)**

**4 (initiator action)**

#### Act3

**5 (initiator action)**

**6 (responder action)**

### 参考
https://github.com/lightningnetwork/lightning-rfc/blob/master/08-transport.md  
http://www.noiseprotocol.org/noise.html  
https://kiririmode.hatenablog.jp/entry/20190217/1550396722  
